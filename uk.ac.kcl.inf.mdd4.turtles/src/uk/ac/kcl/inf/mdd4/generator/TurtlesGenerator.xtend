/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.mdd4.generator

import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.mdd4.turtles.Addition
import uk.ac.kcl.inf.mdd4.turtles.IntExpression
import uk.ac.kcl.inf.mdd4.turtles.IntLiteral
import uk.ac.kcl.inf.mdd4.turtles.IntVarExpression
import uk.ac.kcl.inf.mdd4.turtles.LoopStatement
import uk.ac.kcl.inf.mdd4.turtles.MoveCommand
import uk.ac.kcl.inf.mdd4.turtles.MoveStatement
import uk.ac.kcl.inf.mdd4.turtles.Multiplication
import uk.ac.kcl.inf.mdd4.turtles.Statement
import uk.ac.kcl.inf.mdd4.turtles.TurnCommand
import uk.ac.kcl.inf.mdd4.turtles.TurnStatement
import uk.ac.kcl.inf.mdd4.turtles.TurtleProgram
import uk.ac.kcl.inf.mdd4.turtles.TurtlesFactory
import uk.ac.kcl.inf.mdd4.turtles.VariableDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtlesGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as TurtleProgram
		fsa.generateFile(resource.deriveArduinoFileNameFor, model.doGenerateArduinoCode)

	}

	def deriveArduinoFileNameFor(Resource resource) {
		'folder/file.ino'
	}

	/**
	 * generates code by pasting the fixed head and fixed tail of the program and 
	 * then generating code for each statement
	 * 
	 */
	def String doGenerateArduinoCode(TurtleProgram program) {
		head + '''
			// TODO code should be generated here...
		''' + tail
	}

	def String head() '''
		#include <Arduino.h>
		
		#define MOTOR_A_PWM 13 //D7 A-1A
		#define MOTOR_A_DIR 5  //D1 A1-B
		#define MOTOR_B_PWM 14 //D5 B-1A
		#define MOTOR_B_DIR 12 //D6 B-1B
		#define PWM_SLOW 1000  // slow speed PWM duty cycle
		// for full batteries PWM_SLOW 700 should be better
				
		void setup() {
		
		  Serial.begin(115200);
		
		  pinMode( MOTOR_B_DIR, OUTPUT );
		  pinMode( MOTOR_B_PWM, OUTPUT );
		  digitalWrite( MOTOR_B_DIR, LOW );
		  digitalWrite( MOTOR_B_PWM, LOW );
		
		  pinMode( MOTOR_A_DIR, OUTPUT );
		  pinMode( MOTOR_A_PWM, OUTPUT );
		  digitalWrite( MOTOR_A_DIR, LOW );
		  digitalWrite( MOTOR_A_PWM, LOW );
		}
		
		void loop() {
	'''

	def String tail() '''
		}
		
		void forwardA() {
		  digitalWrite( MOTOR_A_DIR, HIGH ); // direction = forward
		  analogWrite( MOTOR_A_PWM, 1023-PWM_SLOW ); // PWM speed = slow
		}
		void forwardB() {
		  digitalWrite( MOTOR_B_DIR, HIGH ); // direction = forward
		  analogWrite( MOTOR_B_PWM, 1023-PWM_SLOW ); // PWM speed = slow
		}
		
		void stopA() {
		  digitalWrite( MOTOR_A_DIR, LOW ); // direction = forward
		  digitalWrite( MOTOR_A_PWM, LOW ); // PWM speed = slow
		}
		void stopB() {
		  digitalWrite( MOTOR_B_DIR, LOW ); // direction = forward
		  digitalWrite( MOTOR_B_PWM, LOW ); // PWM speed = slow
		}
		
		void backA() {
		  digitalWrite( MOTOR_A_DIR, LOW ); // direction = forward
		  analogWrite( MOTOR_A_PWM, PWM_SLOW ); // PWM speed = slow
		}
		void backB() {
		  digitalWrite( MOTOR_B_DIR, LOW ); // direction = forward
		  analogWrite( MOTOR_B_PWM, PWM_SLOW ); // PWM speed = slow
		}
	'''
}
